<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Air Hockey</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #100f22;
        }
        canvas {
            background-color: #1d1c3b;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Configuration ---
        const WINNING_SCORE = 5;
        const PUCK_MAX_SPEED = 12;
        const AI_DIFFICULTY = 0.085; // How quickly the AI paddle follows the puck

        let player = {};
        let ai = {};
        let puck = {};
        let gameOver = false;
        let winner = '';
        
        // --- Resize and Initialize ---
        function resizeCanvas() {
            const aspectRatio = 10 / 16; // A more vertical aspect ratio like the screenshot
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            if (windowHeight / windowWidth > aspectRatio) {
                canvas.width = windowWidth * 0.95;
                canvas.height = canvas.width / aspectRatio;
            } else {
                canvas.height = windowHeight * 0.95;
                canvas.width = canvas.height * aspectRatio;
            }
            
            initializeGameObjects();
        }

        function initializeGameObjects() {
            // Player paddle
            player = {
                radius: canvas.width * 0.07,
                x: canvas.width / 2,
                y: canvas.height * 0.8,
                score: 0
            };

            // AI paddle
            ai = {
                radius: canvas.width * 0.07,
                x: canvas.width / 2,
                y: canvas.height * 0.2,
                score: 0
            };

            // Puck
            puck = {
                radius: canvas.width * 0.04,
                x: canvas.width / 2,
                y: canvas.height / 2,
                speed: 8,
                vx: 0,
                vy: 0
            };
            
            resetGame();
        }

        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('mousemove', movePlayer);
        canvas.addEventListener('touchmove', movePlayer, { passive: false });
        canvas.addEventListener('click', () => {
             if (gameOver) {
                 gameOver = false;
                 player.score = 0;
                 ai.score = 0;
                 resetGame();
             }
        });


        // --- Player Controls ---
        function movePlayer(e) {
            e.preventDefault();
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;
            
            let inputX = (e.clientX || e.touches[0].clientX) - rect.left - root.scrollLeft;
            let inputY = (e.clientY || e.touches[0].clientY) - rect.top - root.scrollTop;

            player.x = inputX;
            player.y = inputY;

            // Keep player in their half
            if (player.y < canvas.height / 2 + player.radius) {
                player.y = canvas.height / 2 + player.radius;
            }
            if (player.y > canvas.height - player.radius) {
                player.y = canvas.height - player.radius;
            }
            if (player.x < player.radius) {
                player.x = player.radius;
            }
            if (player.x > canvas.width - player.radius) {
                player.x = canvas.width - player.radius;
            }
        }
        
        // --- Drawing Functions ---
        function draw() {
            // Clear canvas and draw background
            ctx.fillStyle = '#1d1c3b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawBackgroundDecor();
            drawTable();
            drawPaddles();
            drawPuck();
            drawScore();

            if (gameOver) {
                drawGameOver();
            }
        }

        function drawBackgroundDecor() {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.beginPath();
            ctx.moveTo(canvas.width * -0.1, canvas.height * 0.2);
            ctx.lineTo(canvas.width * 0.4, canvas.height * 0.3);
            ctx.lineTo(canvas.width * 0.3, canvas.height * 0.7);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(canvas.width * 1.1, canvas.height * 0.8);
            ctx.lineTo(canvas.width * 0.6, canvas.height * 0.7);
            ctx.lineTo(canvas.width * 0.7, canvas.height * 0.3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawTable() {
            const w = canvas.width;
            const h = canvas.height;
            const goalWidth = w * 0.35;
            const cornerRadius = 30;
            const borderThickness = 10;
            
            ctx.save();
            // Neon glow effect
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;

            // Main table border
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = borderThickness;
            
            ctx.beginPath();
            ctx.moveTo(cornerRadius, 0);
            ctx.lineTo(w / 2 - goalWidth / 2, 0);
            ctx.moveTo(w / 2 + goalWidth / 2, 0);
            ctx.lineTo(w - cornerRadius, 0);
            ctx.arcTo(w, 0, w, cornerRadius, cornerRadius);
            ctx.lineTo(w, h - cornerRadius);
            ctx.arcTo(w, h, w - cornerRadius, h, cornerRadius);
            ctx.lineTo(w / 2 + goalWidth / 2, h);
            ctx.moveTo(w / 2 - goalWidth / 2, h);
            ctx.lineTo(cornerRadius, h);
            ctx.arcTo(0, h, 0, h - cornerRadius, cornerRadius);
            ctx.lineTo(0, cornerRadius);
            ctx.arcTo(0, 0, cornerRadius, 0, cornerRadius);
            ctx.stroke();
            
            ctx.restore();

            // Center line and circle
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(w / 2, h / 2, w * 0.15, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        function drawPaddles() {
            // AI Paddle
            drawNeonCircle(ai.x, ai.y, ai.radius, '#ff9900', '#ffcc00');
            // Player Paddle
            drawNeonCircle(player.x, player.y, player.radius, '#00ffff', '#99ffff');
        }

        function drawPuck() {
            ctx.save();
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(puck.x, puck.y, puck.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawNeonCircle(x, y, r, glowColor, centerColor) {
            ctx.save();
            // Outer glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 25;

            // White border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = r * 0.15;
            ctx.beginPath();
            ctx.arc(x, y, r * 0.9, 0, Math.PI * 2);
            ctx.stroke();
            
            // Center fill
            ctx.fillStyle = centerColor;
            ctx.beginPath();
            ctx.arc(x, y, r * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawScore() {
            const w = canvas.width;
            const h = canvas.height;
            const scoreX = w - 40;
            const boxWidth = 50;
            const boxHeight = 40;
            const fontSize = h * 0.04;

            // AI Score
            drawText(ai.score, scoreX, h/2 - 50, fontSize, '#ff9900');
            
            // Separator
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.strokeRect(scoreX - boxWidth/2, h/2 - boxHeight/2, boxWidth, boxHeight);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(scoreX - 10, h/2 - 1.5, 20, 3);
            ctx.fillRect(scoreX - 10, h/2 + 6.5, 20, 3);
            ctx.restore();

            // Player Score
            drawText(player.score, scoreX, h/2 + 50, fontSize, '#00ffff');
        }
        
        function drawText(text, x, y, size, color) {
            ctx.fillStyle = color;
            ctx.font = `bold ${size}px 'Courier New', Courier, monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.fillText(text, x, y);
            ctx.shadowBlur = 0;
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawText(`${winner} Wins!`, canvas.width / 2, canvas.height / 2 - 40, 50, '#ffffff');
            drawText('Click to Play Again', canvas.width / 2, canvas.height / 2 + 20, 20, '#ffffff');
        }

        // --- Game Logic ---
        function update() {
            if (gameOver) return;

            moveAI();
            movePuck();
        }
        
        function moveAI() {
            // AI follows the puck's x-position, with some smoothing
            ai.x += (puck.x - ai.x) * AI_DIFFICULTY;

            // Keep AI in its half
            if (ai.y > canvas.height / 2 - ai.radius) {
                ai.y = canvas.height / 2 - ai.radius;
            }
        }

        function movePuck() {
            puck.x += puck.vx;
            puck.y += puck.vy;

            handleCollisions();
            checkGoal();
        }

        function handleCollisions() {
            // Walls
            if (puck.x - puck.radius < 0 || puck.x + puck.radius > canvas.width) {
                puck.vx *= -1;
            }

            // Paddle collisions
            handlePaddleCollision(player);
            handlePaddleCollision(ai);
        }

        function handlePaddleCollision(paddle) {
            let dx = puck.x - paddle.x;
            let dy = puck.y - paddle.y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < puck.radius + paddle.radius) {
                let angle = Math.atan2(dy, dx);
                puck.vx = Math.cos(angle) * PUCK_MAX_SPEED;
                puck.vy = Math.sin(angle) * PUCK_MAX_SPEED;
            }
        }
        
        function checkGoal() {
            const goalWidth = canvas.width * 0.35;
            const inGoalRange = puck.x > canvas.width / 2 - goalWidth / 2 && puck.x < canvas.width / 2 + goalWidth / 2;

            if (puck.y < puck.radius) { // AI's goal
                if (inGoalRange) {
                    player.score++;
                    checkWin();
                    resetGame();
                } else {
                    puck.vy *= -1;
                }
            } else if (puck.y > canvas.height - puck.radius) { // Player's goal
                if (inGoalRange) {
                    ai.score++;
                    checkWin();
                    resetGame();
                } else {
                    puck.vy *= -1;
                }
            }
        }
        
        function checkWin() {
            if (player.score >= WINNING_SCORE) {
                winner = 'Player';
                gameOver = true;
            } else if (ai.score >= WINNING_SCORE) {
                winner = 'AI';
                gameOver = true;
            }
        }
        
        function resetGame() {
            puck.x = canvas.width / 2;
            puck.y = canvas.height / 2;
            
            // Random start direction
            let angle = Math.random() * Math.PI * 2;
            puck.vx = Math.cos(angle) * puck.speed;
            puck.vy = Math.sin(angle) * puck.speed;
            
            // Ensure it doesn't start moving horizontally
             if(Math.abs(puck.vy) < 2) {
                puck.vy = (puck.vy > 0) ? 2 : -2;
            }
        }

        // --- Main Game Loop ---
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // --- Start Game ---
        resizeCanvas();
        gameLoop();

    </script>
</body>
</html>
