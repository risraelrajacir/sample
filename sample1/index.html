<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird</title>
    <style>
        /* CSS to ensure full screen, no scroll, and centered content */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents scroll bars */
            height: 100%;
            background-color: #333;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border: 2px solid #000;
            background-color: #70c5ce;
            cursor: pointer;
            /* Disables unwanted mobile behaviors */
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="288" height="512"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Responsive Canvas Scaling ---
        function resizeGame() {
            const gameRatio = canvas.width / canvas.height;
            const windowRatio = window.innerWidth / window.innerHeight;
            
            if (windowRatio < gameRatio) {
                // Window is taller than game
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = (window.innerWidth / gameRatio) + 'px';
            } else {
                // Window is wider than game
                canvas.style.height = window.innerHeight + 'px';
                canvas.style.width = (window.innerHeight * gameRatio) + 'px';
            }
        }
        window.addEventListener('resize', resizeGame);
        resizeGame(); // Initial resize

        // --- Asset URLs ---
        const assets = {
            bird: [
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_1.png?raw=true",
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_2.png?raw=true",
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_3.png?raw=true",
                "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bs/bd_ge_1_as_bs_1/be_bd_4.png?raw=true"
            ],
            background: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bgs/bd_ge_1_as_bgs_1/bg_dy_1.png?raw=true",
            base: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_bes/bd_ge_1_as_bes_1/gd_1.png?raw=true",
            pipeTop: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_ps/bd_ge_1_as_ps_1/gn_pe_tp.png?raw=true",
            pipeBottom: "https://github.com/Rajacajustin/gs_1/blob/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_ps/bd_ge_1_as_ps_1/gn_pe_bm.png?raw=true",
            uiBackground: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/UIbg.png?raw=true",
            getReady: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tt_Gt_Ry_ui.png?raw=true",
            gameOver: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tt_Ge_Or_ui.png?raw=true",
            playButton: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/py_ne_ui_bn.png?raw=true",
            replayButton: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/as_ui_1_ui_bs_1/ry_ne_ui_bn.png?raw=true",
            tapSymbol: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tp_sl_ui.png?raw=true",
            tapTickSymbol: "https://github.com/Rajacajustin/gs_1/blob/main/as/as_ui/as_ui_1/tp_Tk_ui.png?raw=true",
            swoosh: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/sh_sd_et.mp3",
            flap: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/fp_sd_et.mp3",
            point: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/pt_sd_et.mp3",
            hit: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/ht_sd_et.mp3",
            die: "https://github.com/Rajacajustin/gs_1/raw/refs/heads/main/bd_ge_1/bd_ge_1_as/bd_ge_1_as_sd_es/bd_ge_1_as_sd_es_1/de_sd_et.mp3"
        };

        const images = {};
        const sounds = {};
        let assetsToLoad = 0;

        function assetLoaded() {
            assetsToLoad--;
            if (assetsToLoad === 0) {
                main();
            }
        }

        function loadAssets() {
            ctx.fillStyle = "black"; ctx.font = "20px Arial"; ctx.textAlign = "center";
            ctx.fillText("Loading...", canvas.width/2, canvas.height/2);
            
            const imageKeys = ['background', 'base', 'pipeTop', 'pipeBottom', 'uiBackground', 'getReady', 'gameOver', 'playButton', 'replayButton', 'tapSymbol', 'tapTickSymbol'];
            assetsToLoad = imageKeys.length + assets.bird.length;
            
            imageKeys.forEach(key => { images[key] = new Image(); images[key].src = assets[key]; images[key].onload = assetLoaded; });
            images.bird = assets.bird.map(src => { const img = new Image(); img.src = src; img.onload = assetLoaded; return img; });
            for (const key of ['swoosh', 'flap', 'point', 'hit', 'die']) { sounds[key] = new Audio(assets[key]); }
        }
        
        function main() {
            let frames = 0;
            const DEGREE = Math.PI / 180;
            const state = { current: 0, getReady: 0, instructions: 1, game: 2, over: 3 };

            const flash = {
                alpha: 0, speed: 0.1,
                start: function() { this.alpha = 0.7; },
                update: function() { this.alpha = Math.max(0, this.alpha - this.speed); },
                draw: function() {
                    if (this.alpha > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                },
                reset: function() { this.alpha = 0; }
            };

            const transition = {
                alpha: 0, speed: 0.05, active: false, targetState: -1,
                start: function(target) {
                    if (this.active) return;
                    this.active = true; this.isFadingOut = true; this.targetState = target; sounds.swoosh.play();
                },
                update: function() {
                    if (!this.active) return;
                    if (this.isFadingOut) {
                        this.alpha = Math.min(1, this.alpha + this.speed);
                        if (this.alpha >= 1) {
                            this.isFadingOut = false; this.isFadingIn = true;
                            if (state.current === state.over) resetGame();
                            state.current = this.targetState;
                        }
                    } else if (this.isFadingIn) {
                        this.alpha = Math.max(0, this.alpha - this.speed);
                        if (this.alpha <= 0) { this.isFadingIn = false; this.active = false; }
                    }
                },
                draw: function() {
                    if (this.alpha > 0) {
                        ctx.fillStyle = `rgba(0, 0, 0, ${this.alpha})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }
            };

            const bg = { draw: () => ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height) };
            
            const base = {
                x: 0, y: canvas.height - 112, w: 336, h: 112, dx: 2,
                draw: function() {
                    ctx.drawImage(images.base, this.x, this.y, this.w, this.h);
                    ctx.drawImage(images.base, this.x + this.w, this.y, this.w, this.h);
                },
                update: function() {
                    if (state.current !== state.over) {
                        this.x -= this.dx;
                        if (this.x <= -this.w) this.x = 0;
                    }
                }
            };

            const bird = {
                x: 80, y: 190, w: 34, h: 24, frame: 0,
                gravity: 0.20, jump: 4.2, speed: 0, rotation: 0,
                draw: function() {
                    let birdImg = images.bird[this.frame];
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                    ctx.drawImage(birdImg, -this.w / 2, -this.h / 2, this.w, this.h);
                    ctx.restore();
                },
                flap: function() { this.speed = -this.jump; },
                update: function() {
                    if (state.current === state.getReady || state.current === state.instructions) {
                        this.frame = Math.floor((frames / 5) % images.bird.length);
                        this.y = 190 + Math.sin(frames * DEGREE * 5) * 8;
                        this.rotation = 0;
                    } else {
                        if (state.current !== state.over || this.y < base.y - this.h/2) {
                            this.speed += this.gravity;
                            this.y += this.speed;
                        }

                        if (this.y + this.h / 2 >= base.y) {
                            this.y = base.y - this.h / 2;
                            if (state.current === state.game) {
                                state.current = state.over; sounds.hit.play(); flash.start(); gameOverSequence.start();
                            }
                        }

                        if (state.current === state.over) {
                            this.frame = 1;
                            if (this.y < base.y - this.h/2) {
                               this.rotation = Math.min(90 * DEGREE, this.rotation + 4 * DEGREE);
                            }
                        } else {
                            this.frame = Math.floor((frames / 5) % images.bird.length);
                            if (this.speed >= 0) {
                                this.rotation = Math.min(90 * DEGREE, this.rotation + 4 * DEGREE);
                            } else {
                                this.rotation = -25 * DEGREE;
                            }
                        }
                    }
                },
                reset: function() { this.speed = 0; this.y = 190; }
            };

            const pipes = {
                position: [], w: 52, h: 320, gap: 100, maxYPos: -40, dx: 2,
                draw: function() { for (let p of this.position) { ctx.drawImage(images.pipeTop, p.x, p.y); ctx.drawImage(images.pipeBottom, p.x, p.y + this.h + this.gap); }},
                update: function() {
                    if (state.current !== state.game) return;
                    if (frames % 100 === 0) this.position.push({ x: canvas.width, y: this.maxYPos - (Math.random() * 200), passed: false });
                    for (let i = this.position.length - 1; i >= 0; i--) {
                        let p = this.position[i];
                        p.x -= this.dx;
                        let b = { left: bird.x - bird.w/2, right: bird.x + bird.w/2, top: bird.y - bird.h/2, bottom: bird.y + bird.h/2 };
                        if (b.right > p.x && b.left < p.x + this.w && (b.top < p.y + this.h || b.bottom > p.y + this.h + this.gap)) {
                            state.current = state.over; sounds.hit.play(); sounds.die.play(); flash.start(); gameOverSequence.start();
                            bird.speed = 0;
                        }
                        if (p.x + this.w < bird.x && !p.passed) { score.value++; sounds.point.play(); p.passed = true; }
                        if (p.x + this.w < 0) this.position.splice(i, 1);
                    }
                },
                reset: function() { this.position = []; }
            };
            
            const ui = {
                titleSize: { w: 225, h: 45 }, panelSize: { w: 225, h: 112 },
                buttonSize: { w: 150, h: 150 }, tapSymbolSize: { w: 80, h: 70 },
                tapSymbolAlpha: 1.0, isFadingTapSymbol: false,
                
                get playRect() { return { x: (canvas.width - this.buttonSize.w) / 2, y: 280, ...this.buttonSize }; },
                get replayRect() { return { x: (canvas.width - this.buttonSize.w) / 2, y: 310, ...this.buttonSize }; },

                draw: function() {
                    if (state.current === state.getReady) {
                        this.drawPulsingButton(images.playButton, this.playRect, frames);
                        ctx.drawImage(images.getReady, (canvas.width - this.titleSize.w) / 2, 100, this.titleSize.w, this.titleSize.h);
                    } else if (state.current === state.instructions || this.isFadingTapSymbol) {
                        this.drawTapAnimation();
                    } else if (state.current === state.over) {
                        gameOverSequence.draw();
                    }
                },
                drawPulsingButton: function(image, rect, frameCount) {
                    const pulse = Math.sin(frameCount * DEGREE * 5) * 0.05 + 1;
                    ctx.save(); ctx.translate(rect.x + rect.w / 2, rect.y + rect.h / 2);
                    ctx.scale(pulse, pulse); ctx.drawImage(image, -rect.w / 2, -rect.h / 2, rect.w, rect.h); ctx.restore();
                },
                drawTapAnimation: function() {
                    ctx.save(); ctx.globalAlpha = this.tapSymbolAlpha;
                    let isTicked = Math.floor(frames / 20) % 2 === 0;
                    let currentSymbol = isTicked ? images.tapTickSymbol : images.tapSymbol;
                    let pulse = Math.sin(frames * DEGREE * 8) * 0.05 + 1;
                    let w = this.tapSymbolSize.w * pulse, h = this.tapSymbolSize.h * pulse;
                    ctx.drawImage(currentSymbol, (canvas.width - w) / 2, 250, w, h); ctx.restore();
                },
                update: function() {
                    if (this.isFadingTapSymbol) {
                        this.tapSymbolAlpha -= 0.05;
                        if (this.tapSymbolAlpha <= 0) { this.isFadingTapSymbol = false; }
                    }
                },
                reset: function() { this.tapSymbolAlpha = 1.0; this.isFadingTapSymbol = false; }
            };

            const gameOverSequence = {
                step: 0, timer: 0, panelY: canvas.height, panelTargetY: 180, panelSpeed: 15,
                start: function() { this.step = 1; this.timer = 0; },
                update: function() {
                    if (this.step === 0) return; this.timer++;
                    if (this.step === 1 && this.timer > 30) { this.step = 2; }
                    if (this.step === 2) {
                        this.panelY = Math.max(this.panelTargetY, this.panelY - this.panelSpeed);
                        if (this.panelY === this.panelTargetY) this.step = 3;
                    }
                    if (this.step === 3 && this.timer > 90) { this.step = 4; }
                },
                draw: function() {
                    if (this.step >= 2) { ctx.drawImage(images.gameOver, (canvas.width - ui.titleSize.w) / 2, 120, ui.titleSize.w, ui.titleSize.h); }
                    if (this.step >= 2) { ctx.drawImage(images.uiBackground, (canvas.width - ui.panelSize.w) / 2, this.panelY, ui.panelSize.w, ui.panelSize.h); }
                    if (this.step === 4) { ui.drawPulsingButton(images.replayButton, ui.replayRect, frames); }
                },
                reset: function() { this.step = 0; this.timer = 0; this.panelY = canvas.height; }
            };

            const score = {
                best: parseInt(localStorage.getItem('flappybird_best')) || 0, value: 0,
                draw: function() {
                    if (state.current === state.game) { drawTextWithShadow(this.value, canvas.width / 2, 50, "35px 'Arial Black', sans-serif", "center"); }
                    else if (state.current === state.over && gameOverSequence.step >= 2) {
                        drawTextWithShadow("Score", 80, gameOverSequence.panelY + 42, "20px 'Arial Black', sans-serif", "left");
                        drawTextWithShadow("Best", 80, gameOverSequence.panelY + 82, "20px 'Arial Black', sans-serif", "left");
                        drawTextWithShadow(this.value, 210, gameOverSequence.panelY + 42, "20px 'Arial Black', sans-serif", "right");
                        drawTextWithShadow(this.best, 210, gameOverSequence.panelY + 82, "20px 'Arial Black', sans-serif", "right");
                    }
                },
                reset: function() { if (this.value > this.best) { this.best = this.value; localStorage.setItem('flappybird_best', this.best); } this.value = 0; }
            };
            
            function drawTextWithShadow(text, x, y, font, align){
                ctx.font = font; ctx.textAlign = align;
                ctx.fillStyle = "#000"; ctx.fillText(text, x + 2, y + 2);
                ctx.fillStyle = "#FFF"; ctx.fillText(text, x, y);
            }

            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                // For touch events, get the first touch
                const clientX = evt.clientX || (evt.touches && evt.touches[0].clientX);
                const clientY = evt.clientY || (evt.touches && evt.touches[0].clientY);
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            }
            function isInside(pos, rect) { return pos.x > rect.x && pos.x < rect.x + rect.w && pos.y < rect.y + rect.h && pos.y > rect.y; }

            function handleInput(evt) {
                if (state.current === state.instructions || state.current === state.game) {
                    if (state.current === state.instructions) {
                        ui.isFadingTapSymbol = true;
                        state.current = state.game;
                    }
                    bird.flap(); sounds.flap.play();
                }
            }
            
            function processClick(evt) {
                if (transition.active) return;
                const mousePos = getMousePos(evt.currentTarget, evt);
                if (state.current === state.getReady && isInside(mousePos, ui.playRect)) {
                    transition.start(state.instructions);
                } else if (state.current === state.over && gameOverSequence.step === 4 && isInside(mousePos, ui.replayRect)) {
                    transition.start(state.getReady);
                } else {
                    handleInput();
                }
            }
            
            canvas.addEventListener('click', processClick);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); processClick(e); }, { passive: false });
            
            document.addEventListener('keydown', (e) => { if (e.code === 'Space') handleInput(); });
            
            function resetGame() { bird.reset(); pipes.reset(); score.reset(); ui.reset(); flash.reset(); gameOverSequence.reset(); }
            function update() { bird.update(); pipes.update(); base.update(); ui.update(); transition.update(); flash.update(); gameOverSequence.update(); }
            function draw() { bg.draw(); pipes.draw(); bird.draw(); base.draw(); ui.draw(); score.draw(); flash.draw(); transition.draw(); }

            function loop() {
                update(); draw(); frames++; requestAnimationFrame(loop);
            }
            loop();
        }

        loadAssets();
    </script>
</body>
</html>
